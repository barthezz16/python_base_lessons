# -*- coding: utf-8 -*-

# Подземелье было выкопано ящеро-подобными монстрами рядом с аномальной рекой, постоянно выходящей из берегов.
# Из-за этого подземелье регулярно затапливается, монстры выживают, но не герои, рискнувшие спуститься к ним в поисках
# приключений.
# Почуяв безнаказанность, ящеры начали совершать набеги на ближайшие деревни. На защиту всех деревень не хватило
# солдат и вас, как известного в этих краях героя, наняли для их спасения.
#
# Карта подземелья представляет собой json-файл под названием rpg.json. Каждая локация в лабиринте описывается объектом,
# в котором находится единственный ключ с названием, соответствующем формату "Location_<N>_tm<T>",
# где N - это номер локации (целое число), а T (вещественное число) - это время,
# которое необходимо для перехода в эту локацию. Например, если игрок заходит в локацию "Location_8_tm30000",
# то он тратит на это 30000 секунд.
# По данному ключу находится список, который содержит в себе строки с описанием монстров а также другие локации.
# Описание монстра представляет собой строку в формате "Mob_exp<K>_tm<M>", где K (целое число) - это количество опыта,
# которое получает игрок, уничтожив данного монстра, а M (вещественное число) - это время,
# которое потратит игрок для уничтожения данного монстра.
# Например, уничтожив монстра "Boss_exp10_tm20", игрок потратит 20 секунд и получит 10 единиц опыта.
# Гарантируется, что в начале пути будет две локации и один монстр
# (то есть в коренном json-объекте содержится список, содержащий два json-объекта, одного монстра и ничего больше).
#
# На прохождение игры игроку дается 123456.0987654321 секунд.
# Цель игры: за отведенное время найти выход ("Hatch")
#
# По мере прохождения вглубь подземелья, оно начинает затапливаться, поэтому
# в каждую локацию можно попасть только один раз,
# и выйти из нее нельзя (то есть двигаться можно только вперед).
#
# Чтобы открыть люк ("Hatch") и выбраться через него на поверхность, нужно иметь не менее 280 очков опыта.
# Если до открытия люка время заканчивается - герой задыхается и умирает, воскрешаясь перед входом в подземелье,
# готовый к следующей попытке (игра начинается заново).
#
# Гарантируется, что искомый путь только один, и будьте аккуратны в рассчетах!
# При неправильном использовании библиотеки decimal человек, играющий с вашим скриптом рискует никогда не найти путь.
#
# Также, при каждом ходе игрока ваш скрипт должен запоминать следущую информацию:
# - текущую локацию
# - текущее количество опыта
# - текущие дату и время (для этого используйте библиотеку datetime)
# После успешного или неуспешного завершения игры вам необходимо записать
# всю собранную информацию в csv файл dungeon.csv.
# Названия столбцов для csv файла: current_location, current_experience, current_date
#
#
# Пример взаимодействия с игроком:
#
# Вы находитесь в Location_0_tm0
# У вас 0 опыта и осталось 123456.0987654321 секунд до наводнения
# Прошло времени: 00:00
#
# Внутри вы видите:
# — Вход в локацию: Location_1_tm1040
# — Вход в локацию: Location_2_tm123456
# Выберите действие:
# 1.Атаковать монстра
# 2.Перейти в другую локацию
# 3.Сдаться и выйти из игры
#
# Вы выбрали переход в локацию Location_2_tm1234567890
#
# Вы находитесь в Location_2_tm1234567890
# У вас 0 опыта и осталось 0.0987654321 секунд до наводнения
# Прошло времени: 20:00
#
# Внутри вы видите:
# — Монстра Mob_exp10_tm10
# — Вход в локацию: Location_3_tm55500
# — Вход в локацию: Location_4_tm66600
# Выберите действие:
# 1.Атаковать монстра
# 2.Перейти в другую локацию
# 3.Сдаться и выйти из игры
#
# Вы выбрали сражаться с монстром
#
# Вы находитесь в Location_2_tm0
# У вас 10 опыта и осталось -9.9012345679 секунд до наводнения
#
# Вы не успели открыть люк!!! НАВОДНЕНИЕ!!! Алярм!
#
# У вас темнеет в глазах... прощай, принцесса...
# Но что это?! Вы воскресли у входа в пещеру... Не зря матушка дала вам оберег :)
# Ну, на этот-то раз у вас все получится! Трепещите, монстры!
# Вы осторожно входите в пещеру... (текст умирания/воскрешения можно придумать свой ;)
#
# Вы находитесь в Location_0_tm0
# У вас 0 опыта и осталось 123456.0987654321 секунд до наводнения
# Прошло уже 0:00:00
# Внутри вы видите:
#  ...
#  ...
#
# и так далее...
import json
import re
from pprint import pprint

with open('rpg.json', 'r', encoding='utf8') as file_with_data:
    data = json.load(file_with_data)


def game(location, exp, remaining_time):
    mob_list = []
    location_list = []
    print(f'Вы находитесь в ', str(list(data.keys())[0]))
    print(f'У вас {exp} опыта и осталось {remaining_time} секунд до наводнения')
    print(f'Прошло времени: 00:00')
    print('Внутри вы видите:')
    for key, location in enumerate(location, start=1):
        # if type(location) == str:
        #     mob_list.append(location)
        #     print('— Монстра: ', location)
        # else:
        #     for value in location:  # TODO цикл тут не нужен, хватит location_list.extend(location)
        # TODO Хотя возможно стоит ещё индекс сохранять на котором эта локации в списке находится - key который
        #         location_list.extend(location)
        #         print('— Вход в локацию: ', value)
        # вот тут не совсем понимаю, если оставить так, то через try/except смог, иначе ошибка TypeError
        # если разкоментратить верхгнюю часть и закоментарить нижнюю, то на втором проходе мобы мешаются с локациями,
        # следовательно надо искать черещ регулярки, но там что то идет не так...
        # TODO Вот это ход не в правильную сторону. Цикл по списку и проверка на тип встречающихся объектов
        # TODO гораздо проще (isinstance поможет сделать это корректно)
        # TODO Если объект строка - значит это моб, если словарь - значит это вход в новую локацию
        try:
            if re.search(re_mobs, location)[0]:
                mob_list.append(location)
                print('— Монстра: ', location)
        except TypeError:
            pass
        try:
            for value in location:
                if str(re.search(re_location, location)[0]):
                    location_list.extend(location)
                    print('— Вход в локацию: ', value)
        except TypeError:
            pass
    print('Выберите действие:')
    if len(mob_list) != 0:
        for key, monster_name in enumerate(mob_list, start=1):
            print(f'1) Атаковать монстра {key} {monster_name}')
    for key, location_name in enumerate(location_list, start=1):
        print(f'2) Перейти в локацию {key} {location_name}')
    print('3) Сдаться и выйти из игры!')
    #  Тут лучше разделить перечень мобов/локаций и действий.
    #  Сперва вывести доступные действия с номерами.
    #  Затем, по выбранному действию распечатывать новые возможные выборы, например список мобов.
    choice = input()
    if int(choice[0]) == 3:
        print('Вы уходите? \nНичего, в следующий раз получится!')
    else:
        while not choice[0].isdigit() or not choice[1].isdigit() or len(choice) > 2:
            choice = input('Введено непрвильное значение попоробуйте еще раз! ')
        if int(choice[0]) == 1:
            while int(choice[1]) > len(mob_list):
                choice = input('Нет такого моба, попробуйте еще раз! ')
            mob_list.pop(int(choice[-1]) - 1)
            # exp += re.search(re_mobs, location)[1] # тут таже проблема, TypeError и все тут....
            # TODO У вас усложнение происходит, в частности потому что всё идёт в одной функции
            # TODO Разделите по частям программу, потестите отдельно.
            # TODO Например создайте вручную список с мобами и потестируйте эту часть кода.
            # TODO Чтобы из списков правильно убирались монстры и опыт возвращался.
            print(exp)
        if int(choice[0]) == 2:
            while int(choice[1]) > len(location_list):
                choice = input('Такого пути нет, попробуйте еще раз! ')
            new_location = int(choice[-1])
            location = location[location_list[new_location - 1]]
        # Так вы запишите вместо локации строку с её названием.
        # Нужно же location = location[индекс][название локации]
        # Т.е. чтобы после этого перехода в локации был список из нужного словаря.
        # тут с индекчами вообще не понятно что должно быть...
        # TODO Индекс нужно либо сохранять вместе с названием локации, как я писал выше
        # TODO Либо брать это название и искать среди ключей у словарей, которые есть в текущей локации
        # TODO Первый способ лучше, как мне кажется.
        game(location, exp, remaining_time)


remaining_time = '123456.0987654321'
# если изначально не писать число в виде строки - теряется точность!
field_names = ['current_location', 'current_experience', 'current_date']
exp = 0

re_location = r'Location_(\d)_tm(\d+)'
re_mobs = r'Mob_exp(\d+)_tm(\d+)'
re_exit = r'Hatch_tm159.098765432'
location = data["Location_0_tm0"]
game(location, exp, remaining_time)

# Учитывая время и опыт, не забывайте о точности вычислений!
# TODO Я бы советовал помимо тестов отдельных частей - разделить всё по классам (или хотя бы на один класс)
# TODO занести все нужные переменные в атрибуты
# TODO там можно разместить списки мобов/локаций с индексами
# TODO Сделать метод, который обновляет эти списки при вхождении в новую локацию
# TODO метод, который изменяет текущую локацию на новую и запускает метод выше
# TODO метод для атаки мобов отдельный, который будет убирать мобов из списка и добавлять опыт герою
